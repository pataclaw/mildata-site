<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>MILDATA</title>
<meta name="description" content="24/7 military intelligence wire. Real-time conflict tracking, flight data, OSINT.">
<meta property="og:title" content="MILDATA — Global Military Intelligence Wire">
<meta property="og:description" content="24/7 military & geopolitical intelligence wire. Real-time conflict tracking.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://mildata.app">
<meta property="og:image" content="/og.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@mildata">
<meta name="twitter:image" content="/og.png">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' rx='4' fill='%230b1117'/><text x='4' y='22' font-family='monospace' font-weight='bold' font-size='16' fill='%2300ff41'>MD</text></svg>">
<style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
html,body{height:100%;overflow:hidden}
body{background:#0b1117;color:#c8d0d8;font-family:'JetBrains Mono','Courier New',monospace;display:flex;flex-direction:column}

#hdr{display:flex;align-items:center;gap:14px;padding:7px 16px;font-size:11px;border-bottom:1px solid rgba(255,255,255,.06);flex-shrink:0;user-select:none;background:#0e151c}
#hdr .spacer{flex:1}
#hdr .follow{font-size:9px;font-weight:600;letter-spacing:.5px;color:rgba(255,255,255,.4);text-decoration:none;border:1px solid rgba(255,255,255,.1);padding:3px 10px;border-radius:2px;transition:all .15s;white-space:nowrap}
#hdr .follow:hover{color:#1d9bf0;border-color:rgba(29,155,240,.4);background:rgba(29,155,240,.06)}
#hdr .follow svg{width:11px;height:11px;vertical-align:-1px;margin-right:4px;fill:currentColor}
#hdr .brand{font-weight:700;font-size:13px;letter-spacing:3px;color:#fff}
#hdr .dot{width:6px;height:6px;border-radius:50%;background:#00ff41;box-shadow:0 0 6px rgba(0,255,65,.4);animation:pulse 2s infinite}
#hdr .stat{color:rgba(255,255,255,.35);font-size:10px}
#hdr .stat b{color:rgba(255,255,255,.7);font-weight:500}
#hdr .live{color:#00ff41;font-weight:700;font-size:10px;letter-spacing:1px}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.3}}

#globe-wrap{flex:1;position:relative;min-height:200px;cursor:grab;background:#080d12;touch-action:none}
#globe-wrap:active{cursor:grabbing}
#globe-wrap canvas{position:absolute;top:0;left:0;width:100%;height:100%}

#filters{display:flex;gap:6px;padding:6px 16px;border-top:1px solid rgba(255,255,255,.04);border-bottom:1px solid rgba(255,255,255,.04);flex-shrink:0;overflow-x:auto;user-select:none;background:#0e151c}
.chip{padding:3px 10px;font-size:9px;font-family:inherit;font-weight:500;letter-spacing:.5px;border:1px solid rgba(255,255,255,.08);background:transparent;color:rgba(255,255,255,.3);border-radius:2px;cursor:pointer;white-space:nowrap;transition:all .15s;text-transform:uppercase}
.chip:hover{border-color:rgba(255,255,255,.15);color:rgba(255,255,255,.6)}
.chip.active{border-color:rgba(0,255,65,.4);color:#00ff41;background:rgba(0,255,65,.05)}

#feed{flex:0 0 auto;height:35%;min-height:120px;overflow-y:auto;padding:0;background:#0a1018}
#feed::-webkit-scrollbar{width:3px}
#feed::-webkit-scrollbar-track{background:transparent}
#feed::-webkit-scrollbar-thumb{background:rgba(255,255,255,.08);border-radius:2px}

.wire{padding:8px 16px;font-size:11px;line-height:1.5;border-bottom:1px solid rgba(255,255,255,.03);transition:background .15s}
.wire:hover{background:rgba(255,255,255,.02)}
.wire .text{color:rgba(255,255,255,.75)}
.wire .src{color:rgba(255,255,255,.2);font-size:9px;margin-top:3px;display:flex;gap:8px}
.wire .src .name{color:rgba(100,160,220,.5)}
.wire .src .time{color:rgba(255,255,255,.15)}
.wire.flash{animation:wireFlash .8s}
@keyframes wireFlash{0%{background:rgba(0,255,65,.06)}100%{background:transparent}}
</style>
</head>
<body>
<div id="hdr">
  <span class="brand">MILDATA</span>
  <span class="dot"></span>
  <span class="stat"><b id="ac-count">-</b> aircraft</span>
  <span class="stat"><b id="ship-count">-</b> vessels</span>
  <span class="stat"><b id="wire-count">-</b> wires</span>
  <span id="conn-status" class="stat">connecting...</span>
  <span class="spacer"></span>
  <a class="follow" href="https://x.com/mildata" target="_blank" rel="noopener"><svg viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>FOLLOW</a>
</div>
<div id="globe-wrap">
  <canvas id="globe"></canvas>
</div>
<div id="filters">
  <button class="chip active" data-region="all">All</button>
  <button class="chip" data-region="europe">Europe</button>
  <button class="chip" data-region="mideast">Mideast</button>
  <button class="chip" data-region="indopac">Indo-Pac</button>
  <button class="chip" data-region="africa">Africa</button>
  <button class="chip" data-region="americas">Americas</button>
</div>
<div id="feed"></div>

<script>
// ─── Globe Setup ────────────────────────────────────
const canvas = document.getElementById('globe');
const ctx = canvas.getContext('2d');
let W, H, cx, cy, R, baseR;
let zoomLevel = 1;
const ZOOM_MIN = 0.8, ZOOM_MAX = 5;

function resize() {
  const wrap = document.getElementById('globe-wrap');
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  const w = wrap.clientWidth, h = wrap.clientHeight;
  canvas.width = w * dpr; canvas.height = h * dpr;
  canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  W = w; H = h; cx = W / 2; cy = H / 2;
  baseR = Math.min(cx, cy) - 10;
  R = baseR * zoomLevel;
}
resize();
window.addEventListener('resize', resize);

// ─── Alliance Color System ───────────────────────────
const ALLIANCE = {
  nato:    { color: [80, 160, 255], label: 'NATO' },
  russia:  { color: [255, 140, 40], label: 'RUSSIA' },
  china:   { color: [255, 60, 60],  label: 'CHINA' },
  other:   { color: [140, 140, 140], label: 'OTHER' },
};
function allianceColor(al) { return (ALLIANCE[al] || ALLIANCE.other).color; }

// ─── Ship Data ──────────────────────────────────────
let ships = { t: null, n: 0, s: [] };
let projectedShips = [];

// ─── Land Data (loaded from Natural Earth via CDN) ───
let LAND = [];

async function loadLandData() {
  try {
    // Load topojson-client library
    await new Promise((resolve, reject) => {
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js';
      s.onload = resolve; s.onerror = reject;
      document.head.appendChild(s);
    });
    // Fetch Natural Earth 50m land polygons (accurate coastlines)
    const resp = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/land-50m.json');
    const topo = await resp.json();
    const land = topojson.feature(topo, topo.objects.land);
    LAND = [];
    function extractRings(geom) {
      if (geom.type === 'MultiPolygon') {
        for (const poly of geom.coordinates) LAND.push(poly[0]);
      } else if (geom.type === 'Polygon') {
        LAND.push(geom.coordinates[0]);
      } else if (geom.type === 'GeometryCollection') {
        for (const g of geom.geometries) extractRings(g);
      }
    }
    const geom = land.geometry || land;
    if (land.type === 'FeatureCollection') {
      for (const f of land.features) extractRings(f.geometry);
    } else {
      extractRings(geom);
    }
    console.log('Land data loaded:', LAND.length, 'polygons');
  } catch (e) {
    console.error('Land data load failed:', e);
  }
}

// ─── Projection ─────────────────────────────────────
let rotation = 0, tilt = 0;
function lonLatTo3D(lon, lat, r) {
  const phi = (90 - lat) * Math.PI / 180;
  const theta = (lon + rotation) * Math.PI / 180;
  let x = r * Math.sin(phi) * Math.sin(theta);
  let y = r * Math.cos(phi);
  let z = r * Math.sin(phi) * Math.cos(theta);
  const a = tilt * Math.PI / 180;
  const ca = Math.cos(a), sa = Math.sin(a);
  return { x, y: y * ca - z * sa, z: y * sa + z * ca };
}
function proj(p) { return { x: cx + p.x, y: cy - p.y, z: p.z }; }
function lerpPt(a, b, t) { return { x: a.x+(b.x-a.x)*t, y: a.y+(b.y-a.y)*t, z: a.z+(b.z-a.z)*t }; }

// ─── Vector Land Polygon Drawing ────────────────────
function drawLandPoly(poly, fillStyle) {
  // Subdivide edges for smooth globe curves (~3° per segment)
  const allPts = [];
  for (let i = 0; i < poly.length; i++) {
    const [lon1, lat1] = poly[i];
    const [lon2, lat2] = poly[(i + 1) % poly.length];
    // Handle antimeridian crossing (±180° wrap)
    let dlon = lon2 - lon1;
    if (dlon > 180) dlon -= 360;
    if (dlon < -180) dlon += 360;
    const dlat = lat2 - lat1;
    const dist = Math.hypot(dlon, dlat);
    const steps = Math.max(1, Math.ceil(dist / 3));
    for (let s = 0; s < steps; s++) {
      const t = s / steps;
      const p3d = lonLatTo3D(lon1 + dlon * t, lat1 + dlat * t, R);
      allPts.push(proj(p3d));
    }
  }

  // Extract visible segments (z > 0 = front hemisphere)
  const segments = [];
  let cur = [];
  for (let i = 0; i < allPts.length; i++) {
    const p = allPts[i];
    const prev = allPts[(i - 1 + allPts.length) % allPts.length];
    if (p.z > 0) {
      if (cur.length === 0 && prev.z <= 0) {
        cur.push(lerpPt(prev, p, -prev.z / (p.z - prev.z)));
      }
      cur.push(p);
    } else if (cur.length > 0) {
      cur.push(lerpPt(prev, p, -prev.z / (p.z - prev.z)));
      segments.push(cur);
      cur = [];
    }
  }
  if (cur.length > 0) {
    if (segments.length > 0 && allPts[0].z > 0) {
      segments[0] = cur.concat(segments[0]);
    } else {
      segments.push(cur);
    }
  }
  if (segments.length === 0) return;

  // Draw each visible segment, closing along the limb arc
  for (const seg of segments) {
    if (seg.length < 3) continue;
    ctx.beginPath();
    ctx.moveTo(seg[0].x, seg[0].y);
    for (let i = 1; i < seg.length; i++) ctx.lineTo(seg[i].x, seg[i].y);

    // Close along the globe limb (arc from last to first point)
    const a1 = Math.atan2(seg[seg.length - 1].y - cy, seg[seg.length - 1].x - cx);
    const a2 = Math.atan2(seg[0].y - cy, seg[0].x - cx);
    // Choose shorter arc direction
    let da = a2 - a1;
    if (da > Math.PI) da -= 2 * Math.PI;
    if (da < -Math.PI) da += 2 * Math.PI;
    ctx.arc(cx, cy, R, a1, a1 + da, da < 0);
    ctx.closePath();
    ctx.fillStyle = fillStyle;
    ctx.fill();
  }
}

// ─── Interactive Rotation + Zoom ────────────────────
let dragging = false, dragStartX = 0, dragStartY = 0, dragRotStart = 0, dragTiltStart = 0;
let autoRotate = true, lastDragTime = 0;
let pinchDist = 0, dragMoved = false;
let projectedFlights = [], projectedPings = [];
let selectedItem = null;
const wrap = document.getElementById('globe-wrap');

wrap.addEventListener('mousedown', e => {
  dragging = true; dragMoved = false;
  dragStartX = e.clientX; dragStartY = e.clientY;
  dragRotStart = rotation; dragTiltStart = tilt;
  autoRotate = false;
});
wrap.addEventListener('mousemove', e => {
  if (dragging) {
    const dx = e.clientX - dragStartX, dy = e.clientY - dragStartY;
    if (Math.abs(dx) > 3 || Math.abs(dy) > 3) dragMoved = true;
    rotation = dragRotStart + dx * 0.3 / zoomLevel;
    tilt = Math.max(-80, Math.min(80, dragTiltStart - dy * 0.3 / zoomLevel));
    lastDragTime = Date.now();
  } else {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    let hover = false;
    for (const f of projectedFlights) { if (Math.hypot(f.sx - x, f.sy - y) < 16) { hover = true; break; } }
    if (!hover) for (const s of projectedShips) { if (Math.hypot(s.sx - x, s.sy - y) < 16) { hover = true; break; } }
    if (!hover) for (const p of projectedPings) { if (Math.hypot(p.sx - x, p.sy - y) < 16) { hover = true; break; } }
    wrap.style.cursor = hover ? 'pointer' : 'grab';
  }
});
window.addEventListener('mouseup', e => {
  if (dragging && !dragMoved) handleClick(e.clientX, e.clientY);
  dragging = false;
});

let touchStartPos = null;
wrap.addEventListener('touchstart', e => {
  e.preventDefault();
  if (e.touches.length === 2) {
    dragging = false;
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    pinchDist = Math.sqrt(dx * dx + dy * dy);
  } else if (e.touches.length === 1) {
    dragging = true; dragMoved = false;
    dragStartX = e.touches[0].clientX; dragStartY = e.touches[0].clientY;
    dragRotStart = rotation; dragTiltStart = tilt;
    autoRotate = false;
    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }
}, { passive: false });
wrap.addEventListener('touchmove', e => {
  e.preventDefault();
  if (e.touches.length === 2 && pinchDist) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const nd = Math.sqrt(dx * dx + dy * dy);
    zoomLevel = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, zoomLevel * (nd / pinchDist)));
    pinchDist = nd; R = baseR * zoomLevel;
  } else if (dragging && e.touches.length === 1) {
    const dx = e.touches[0].clientX - dragStartX, dy = e.touches[0].clientY - dragStartY;
    if (Math.abs(dx) > 3 || Math.abs(dy) > 3) dragMoved = true;
    rotation = dragRotStart + dx * 0.3 / zoomLevel;
    tilt = Math.max(-80, Math.min(80, dragTiltStart - dy * 0.3 / zoomLevel));
    lastDragTime = Date.now();
  }
}, { passive: false });
wrap.addEventListener('touchend', () => {
  if (dragging && !dragMoved && touchStartPos) handleClick(touchStartPos.x, touchStartPos.y);
  dragging = false; pinchDist = 0; touchStartPos = null;
});

wrap.addEventListener('wheel', e => {
  e.preventDefault();
  zoomLevel = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, zoomLevel * (e.deltaY > 0 ? 0.92 : 1.08)));
  R = baseR * zoomLevel;
  autoRotate = false; lastDragTime = Date.now();
}, { passive: false });

function handleClick(px, py) {
  const rect = canvas.getBoundingClientRect();
  const x = px - rect.left, y = py - rect.top;
  let closest = null, closestDist = 18;
  for (const f of projectedFlights) { const d = Math.hypot(f.sx - x, f.sy - y); if (d < closestDist) { closest = { type: 'flight', data: f.data, id: f.data.c || f.data.i }; closestDist = d; } }
  for (const s of projectedShips) { const d = Math.hypot(s.sx - x, s.sy - y); if (d < closestDist) { closest = { type: 'ship', data: s.data, id: s.data.n || s.data.mmsi }; closestDist = d; } }
  for (const p of projectedPings) { const d = Math.hypot(p.sx - x, p.sy - y); if (d < closestDist) { closest = { type: 'ping', data: p.data, id: p.data.geo?.label }; closestDist = d; } }
  if (closest) {
    if (selectedItem && selectedItem.id === closest.id && selectedItem.type === closest.type) selectedItem = null;
    else selectedItem = closest;
  } else selectedItem = null;
}

// ─── Geocoding ──────────────────────────────────────
const GEO = {
  'UKRAINE':[48.4,35],'KYIV':[50.45,30.52],'POKROVSK':[48.3,37.2],'DNIPRO':[48.5,35],
  'KHARKIV':[49.99,36.23],'ODESA':[46.48,30.73],'RUSSIA':[55.75,37.62],'MOSCOW':[55.75,37.62],
  'CRIMEA':[44.95,34.1],'IRAN':[35.7,51.4],'TEHRAN':[35.7,51.4],'IRAQ':[33.3,44.4],
  'BAGHDAD':[33.3,44.4],'ISRAEL':[31.8,35.2],'JERUSALEM':[31.8,35.2],'GAZA':[31.5,34.47],
  'HEZBOLLAH':[33.9,35.5],'LEBANON':[33.9,35.5],'SYRIA':[33.5,36.3],'YEMEN':[15.35,44.2],
  'HOUTHI':[15.35,44.2],'QATAR':[25.3,51.5],'SAUDI':[24.7,46.7],'TAIWAN':[24.5,118.1],
  'CHINA':[39.9,116.4],'BEIJING':[39.9,116.4],'DPRK':[39,125.7],'NORTH KOREA':[39,125.7],
  'SOUTH KOREA':[37.5,127],'SEOUL':[37.5,127],'JAPAN':[35.7,139.7],'SUDAN':[19.6,37.2],
  'NATO':[50.88,4.38],'ARCTIC':[69,18.9],'ROMANIA':[44.4,26.1],'POLAND':[52.2,21],
  'PENTAGON':[38.87,-77.05],'WASHINGTON':[38.9,-77.04],'DIEGO GARCIA':[-7.3,72.4],
  'GUAM':[13.4,144.8],'AFGHANISTAN':[34.5,69.2],'PAKISTAN':[33.7,73],'ETHIOPIA':[9,38.7],
  'SOMALIA':[2,45.3],'LIBYA':[32.9,13.2],'NIGER':[13.5,2.1],'MALI':[12.6,-8],
  'MYANMAR':[19.76,96.07],'PHILIPPINES':[14.6,121],'SOUTH CHINA SEA':[15,114],
  'RED SEA':[20,38.5],'BLACK SEA':[43.5,34],'INDIA':[20.6,79],'INDOPACOM':[20,150],
};
function geocode(text) {
  const u = text.toUpperCase();
  let best = null, len = 0;
  for (const [k, c] of Object.entries(GEO)) {
    if (u.includes(k) && k.length > len) { best = { lat: c[0], lon: c[1], label: k }; len = k.length; }
  }
  return best;
}
function classifyRegion(text) {
  const u = text.toUpperCase();
  if (['UKRAINE','RUSSIA','NATO','ARCTIC','ROMANIA','POLAND','MOSCOW','CRIMEA','BLACK SEA','EUROPE'].some(k => u.includes(k))) return 'europe';
  if (['IRAN','IRAQ','ISRAEL','GAZA','SYRIA','YEMEN','HOUTHI','LEBANON','HEZBOLLAH','QATAR','SAUDI','RED SEA'].some(k => u.includes(k))) return 'mideast';
  if (['CHINA','TAIWAN','DPRK','NORTH KOREA','SOUTH KOREA','JAPAN','PHILIPPINES','SOUTH CHINA SEA','INDOPACOM','INDIA','MYANMAR'].some(k => u.includes(k))) return 'indopac';
  if (['SUDAN','ETHIOPIA','SOMALIA','LIBYA','NIGER','MALI','AFRICA'].some(k => u.includes(k))) return 'africa';
  if (['PENTAGON','WASHINGTON','GUAM','AMERICAS'].some(k => u.includes(k))) return 'americas';
  return 'other';
}

// ─── Data + SSE ─────────────────────────────────────
let flights = { a: [] }, wireItems = [], activeRegion = 'all';

function connectSSE() {
  const es = new EventSource('/api/stream');
  const status = document.getElementById('conn-status');
  es.onopen = () => { status.className = 'live'; status.textContent = 'LIVE'; };
  es.onerror = () => { status.className = 'stat'; status.textContent = 'reconnecting...'; };
  es.onmessage = (e) => {
    try {
      const msg = JSON.parse(e.data);
      if (msg.type === 'init') { wireItems = msg.items.map(enrichWire); renderFeed(); }
      else if (msg.type === 'wire') { wireItems.unshift(enrichWire(msg.item)); if (wireItems.length > 100) wireItems.pop(); renderFeed(true); }
      else if (msg.type === 'flights') { flights = msg.data; document.getElementById('ac-count').textContent = flights.n || 0; }
      else if (msg.type === 'ships') { ships = msg.data; document.getElementById('ship-count').textContent = ships.n || 0; }
    } catch (err) {}
  };
}
function enrichWire(item) { return { ...item, geo: geocode(item.text || ''), region: classifyRegion(item.text || '') }; }
async function fetchFlights() { try { const r = await fetch('/api/flights'); flights = await r.json(); document.getElementById('ac-count').textContent = flights.n || 0; } catch (e) {} }
async function fetchShips() { try { const r = await fetch('/api/ships'); ships = await r.json(); document.getElementById('ship-count').textContent = ships.n || 0; } catch (e) {} }

// ─── Feed ───────────────────────────────────────────
function renderFeed(flash) {
  const feed = document.getElementById('feed');
  const filtered = activeRegion === 'all' ? wireItems : wireItems.filter(w => w.region === activeRegion);
  document.getElementById('wire-count').textContent = wireItems.length;
  feed.innerHTML = filtered.map((w, i) => `<div class="wire${flash && i === 0 ? ' flash' : ''}"><span class="text">${esc(w.text || '')}</span><div class="src"><span class="name">${esc(w.source || '')}</span><span class="time">${timeAgo(w.timestamp)}</span></div></div>`).join('');
}
function esc(s) { return s.replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function timeAgo(ts) {
  if (!ts) return '';
  const s = Math.floor((Date.now() - new Date(ts).getTime()) / 1000);
  if (s < 60) return s + 's ago'; if (s < 3600) return Math.floor(s / 60) + 'm ago';
  if (s < 86400) return Math.floor(s / 3600) + 'h ago'; return Math.floor(s / 86400) + 'd ago';
}
document.querySelectorAll('.chip').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.chip').forEach(b => b.classList.remove('active'));
    btn.classList.add('active'); activeRegion = btn.dataset.region; renderFeed();
  });
});

// ─── Globe Rendering (full vector) ──────────────────
function drawGlobe(t) {
  ctx.clearRect(0, 0, W, H);
  projectedFlights = [];
  projectedPings = [];

  // ─── Ocean sphere with 3D gradient shading ─────
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, R, 0, Math.PI * 2);
  ctx.clip();

  const oceanGrad = ctx.createRadialGradient(cx - R * 0.25, cy - R * 0.25, R * 0.05, cx, cy, R);
  oceanGrad.addColorStop(0, '#0f1a24');
  oceanGrad.addColorStop(0.6, '#0a1018');
  oceanGrad.addColorStop(1, '#050a0e');
  ctx.fillStyle = oceanGrad;
  ctx.fillRect(cx - R, cy - R, R * 2, R * 2);

  // ─── Land polygons with gradient shading ───────
  const landGrad = ctx.createRadialGradient(cx - R * 0.25, cy - R * 0.25, R * 0.05, cx, cy, R);
  landGrad.addColorStop(0, '#0a5518');
  landGrad.addColorStop(0.6, '#063d0e');
  landGrad.addColorStop(1, '#021a06');
  for (const poly of LAND) drawLandPoly(poly, landGrad);

  // ─── Grid lines (inside clip) ──────────────────
  ctx.lineWidth = 0.5;
  for (let glon = -180; glon < 180; glon += 30) {
    for (let glat = -89; glat < 89; glat += 4) {
      const p1 = lonLatTo3D(glon, glat, R), s1 = proj(p1);
      const p2 = lonLatTo3D(glon, glat + 4, R), s2 = proj(p2);
      if (Math.min(s1.z, s2.z) < -R * 0.05) continue;
      const a = Math.min(0.1, 0.02 + (Math.min(s1.z, s2.z) / R) * 0.08);
      ctx.strokeStyle = `rgba(100,160,220,${a})`;
      ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
    }
  }
  for (let glat = -75; glat <= 75; glat += 15) {
    for (let glon = -180; glon < 180; glon += 4) {
      const p1 = lonLatTo3D(glon, glat, R), s1 = proj(p1);
      const p2 = lonLatTo3D(glon + 4, glat, R), s2 = proj(p2);
      if (Math.min(s1.z, s2.z) < -R * 0.05) continue;
      const a = Math.min(0.1, 0.02 + (Math.min(s1.z, s2.z) / R) * 0.08);
      ctx.strokeStyle = `rgba(100,160,220,${a})`;
      ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
    }
  }

  ctx.restore(); // remove clip

  // ─── Globe outline ──────────────────────────────
  ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2);
  ctx.strokeStyle = 'rgba(100,160,220,0.12)'; ctx.lineWidth = 1.5; ctx.stroke();

  // ─── Flight Blips + Trail ──────────────────────
  const dotR = Math.max(2, R * 0.012);
  for (const ac of (flights.a || [])) {
    if (ac.la == null || ac.lo == null) continue;
    const p = lonLatTo3D(ac.lo, ac.la, R), s = proj(p);
    if (s.z < R * 0.1) continue;
    if (Math.hypot(s.x - cx, s.y - cy) > R - 2) continue;

    projectedFlights.push({ sx: s.x, sy: s.y, data: ac });

    const hdg = (ac.d || 0) * Math.PI / 180;
    const trailLen = 6, trailStep = dotR * 1.8;
    const acColor = allianceColor(ac.al);

    ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(hdg);
    for (let ti = 1; ti <= trailLen; ti++) {
      ctx.beginPath(); ctx.arc(0, trailStep * ti, dotR * 0.3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${acColor[0]},${acColor[1]},${acColor[2]},${0.3 * (1 - ti / trailLen)})`; ctx.fill();
    }
    const sz = dotR * 1.5;
    ctx.beginPath(); ctx.moveTo(0, -sz); ctx.lineTo(-sz * 0.5, sz * 0.4); ctx.lineTo(sz * 0.5, sz * 0.4);
    ctx.closePath(); ctx.fillStyle = `rgba(${acColor[0]},${acColor[1]},${acColor[2]},0.8)`; ctx.fill();
    ctx.restore();

    if (ac.c && s.z > R * 0.4 && sz > 2 && zoomLevel > 1.5) {
      ctx.font = `${Math.max(7, R * 0.025)}px JetBrains Mono`;
      ctx.fillStyle = `rgba(${acColor[0]},${acColor[1]},${acColor[2]},0.35)`;
      ctx.textAlign = s.x < cx ? 'right' : 'left';
      ctx.fillText(ac.c, s.x + (s.x < cx ? -sz - 3 : sz + 3), s.y + 2);
    }
  }

  // ─── Naval Assets ──────────────────────────────
  projectedShips = [];
  const shipR = Math.max(3, R * 0.015);
  for (const sh of (ships.s || [])) {
    if (sh.la == null || sh.lo == null) continue;
    const p = lonLatTo3D(sh.lo, sh.la, R), s = proj(p);
    if (s.z < R * 0.1) continue;
    if (Math.hypot(s.x - cx, s.y - cy) > R - 2) continue;

    projectedShips.push({ sx: s.x, sy: s.y, data: sh });
    const sc = allianceColor(sh.al);
    const hdg = (sh.d || 0) * Math.PI / 180;
    const sz = shipR * 1.5;

    ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(hdg);
    // Ship hull shape (top-down view)
    ctx.beginPath();
    ctx.moveTo(0, -sz);
    ctx.lineTo(sz * 0.35, -sz * 0.15);
    ctx.lineTo(sz * 0.3, sz * 0.65);
    ctx.lineTo(-sz * 0.3, sz * 0.65);
    ctx.lineTo(-sz * 0.35, -sz * 0.15);
    ctx.closePath();
    ctx.fillStyle = `rgba(${sc[0]},${sc[1]},${sc[2]},0.85)`;
    ctx.fill();
    ctx.strokeStyle = `rgba(${sc[0]},${sc[1]},${sc[2]},0.4)`;
    ctx.lineWidth = 0.5; ctx.stroke();
    ctx.restore();

    // Wake trail
    ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(hdg);
    for (let wi = 1; wi <= 4; wi++) {
      ctx.beginPath(); ctx.arc(0, sz + wi * shipR * 0.8, shipR * 0.2, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${sc[0]},${sc[1]},${sc[2]},${0.25 * (1 - wi / 5)})`; ctx.fill();
    }
    ctx.restore();

    // Label — only carriers at default zoom, all when zoomed
    const showLabel = sh.n && s.z > R * 0.4 && (zoomLevel > 1.5 || sh.tp === 'carrier');
    if (showLabel) {
      ctx.font = `${Math.max(7, R * 0.022)}px JetBrains Mono`;
      ctx.fillStyle = `rgba(${sc[0]},${sc[1]},${sc[2]},0.4)`;
      ctx.textAlign = s.x < cx ? 'right' : 'left';
      ctx.fillText(sh.n, s.x + (s.x < cx ? -sz - 3 : sz + 3), s.y + 2);
    }
  }

  // ─── Event Pings ────────────────────────────────
  const events = wireItems.filter(w => w.geo).slice(0, 15);
  const pingR = Math.max(2, R * 0.02);
  for (let i = 0; i < events.length; i++) {
    const ev = events[i];
    const p = lonLatTo3D(ev.geo.lon, ev.geo.lat, R), s = proj(p);
    if (s.z < R * 0.15 || Math.hypot(s.x - cx, s.y - cy) > R - 2) continue;

    projectedPings.push({ sx: s.x, sy: s.y, data: ev });

    const phase = (t * 0.8 + i * 2.3) % 6;
    const alpha = i < 3 ? (0.7 + Math.sin(t * 2) * 0.2) : (phase < 3 ? 0.6 : 0.12);

    ctx.beginPath(); ctx.arc(s.x, s.y, pingR, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,60,60,${alpha})`; ctx.fill();

    if (i < 5) {
      const rPhase = (t * 0.6 + i * 2.3) % 3;
      ctx.beginPath(); ctx.arc(s.x, s.y, pingR + rPhase * pingR * 2, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255,60,60,${Math.max(0, 1 - rPhase / 3) * 0.4})`; ctx.lineWidth = 0.8; ctx.stroke();
    }

    if (i < 8 && s.z > R * 0.3) {
      ctx.font = `500 ${Math.max(8, R * 0.028)}px JetBrains Mono`;
      ctx.fillStyle = `rgba(255,90,90,${Math.min(0.6, alpha)})`;
      ctx.textAlign = s.x < cx ? 'right' : 'left';
      const off = pingR + 4;
      ctx.fillText(ev.geo.label, s.x + (s.x < cx ? -off : off), s.y - off * 0.5);
    }
  }

  // ─── Selected Item Info Popup ──────────────────
  if (selectedItem) {
    let sx = null, sy = null, lines = [], borderColor = 'rgba(100,160,220,0.5)';
    if (selectedItem.type === 'flight') {
      const ac = selectedItem.data;
      if (ac.la != null && ac.lo != null) {
        const s = proj(lonLatTo3D(ac.lo, ac.la, R));
        if (s.z >= R * 0.1) {
          sx = s.x; sy = s.y;
          const ac_ = allianceColor(ac.al); borderColor = `rgba(${ac_[0]},${ac_[1]},${ac_[2]},0.5)`;
          lines.push(ac.c || ac.h || 'UNKNOWN');
          if (ac.t) lines.push(ac.t);
          lines.push(Math.abs(ac.la).toFixed(2) + (ac.la >= 0 ? '\u00B0N' : '\u00B0S') + '  ' + Math.abs(ac.lo).toFixed(2) + (ac.lo >= 0 ? '\u00B0E' : '\u00B0W'));
          if (ac.a != null) lines.push('ALT ' + Math.round(ac.a) + 'm');
          if (ac.s != null) lines.push('SPD ' + Math.round(ac.s) + 'kn');
          if (ac.d != null) lines.push('HDG ' + Math.round(ac.d) + '\u00B0');
          if (ac.al) lines.push(ac.al.toUpperCase());
        }
      }
    } else if (selectedItem.type === 'ship') {
      const sh = selectedItem.data;
      if (sh.la != null && sh.lo != null) {
        const s = proj(lonLatTo3D(sh.lo, sh.la, R));
        if (s.z >= R * 0.1) {
          sx = s.x; sy = s.y;
          const sc = allianceColor(sh.al); borderColor = `rgba(${sc[0]},${sc[1]},${sc[2]},0.5)`;
          lines.push(sh.n || sh.mmsi || 'UNKNOWN');
          lines.push(Math.abs(sh.la).toFixed(2) + (sh.la >= 0 ? '\u00B0N' : '\u00B0S') + '  ' + Math.abs(sh.lo).toFixed(2) + (sh.lo >= 0 ? '\u00B0E' : '\u00B0W'));
          if (sh.tp) lines.push(sh.tp.toUpperCase());
          if (sh.d != null) lines.push('HDG ' + Math.round(sh.d) + '\u00B0');
          if (sh.al) lines.push((ALLIANCE[sh.al] || ALLIANCE.other).label);
        }
      }
    } else if (selectedItem.type === 'ping') {
      const ev = selectedItem.data;
      if (ev.geo) {
        const s = proj(lonLatTo3D(ev.geo.lon, ev.geo.lat, R));
        if (s.z >= R * 0.1) {
          sx = s.x; sy = s.y; borderColor = 'rgba(255,90,90,0.5)';
          lines.push(ev.geo.label);
          lines.push(Math.abs(ev.geo.lat).toFixed(2) + (ev.geo.lat >= 0 ? '\u00B0N' : '\u00B0S') + '  ' + Math.abs(ev.geo.lon).toFixed(2) + (ev.geo.lon >= 0 ? '\u00B0E' : '\u00B0W'));
          if (ev.source) lines.push(ev.source);
          if (ev.timestamp) lines.push(timeAgo(ev.timestamp));
        }
      }
    }
    if (sx != null && lines.length > 0) {
      const fontSize = Math.max(9, Math.min(11, R * 0.035));
      ctx.font = `500 ${fontSize}px JetBrains Mono`;
      const pad = 8, lineH = fontSize + 4;
      const boxW = Math.max(...lines.map(l => ctx.measureText(l).width)) + pad * 2;
      const boxH = lines.length * lineH + pad * 2;
      let bx = sx + 16, by = sy - boxH / 2;
      if (bx + boxW > W - 4) bx = sx - boxW - 16;
      if (by < 4) by = 4; if (by + boxH > H - 4) by = H - boxH - 4;

      ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(bx < sx ? bx + boxW : bx, by + boxH / 2);
      ctx.strokeStyle = borderColor; ctx.lineWidth = 0.8; ctx.stroke();
      ctx.fillStyle = 'rgba(11,17,23,0.92)'; ctx.fillRect(bx, by, boxW, boxH);
      ctx.strokeStyle = borderColor; ctx.lineWidth = 1; ctx.strokeRect(bx, by, boxW, boxH);
      ctx.textAlign = 'left';
      for (let li = 0; li < lines.length; li++) {
        ctx.fillStyle = li === 0 ? 'rgba(255,255,255,0.9)' : 'rgba(200,208,216,0.65)';
        ctx.fillText(lines[li], bx + pad, by + pad + (li + 1) * lineH - 3);
      }
    }
  }

  // ─── Alliance Legend ───────────────────────────────
  const legFontSize = Math.max(8, Math.min(10, R * 0.03));
  const legPad = 6, legDot = 4, legGap = 5, legLineH = legFontSize + 4;
  const legItems = Object.entries(ALLIANCE);
  const legH = legItems.length * legLineH + legPad * 2;
  const legW = 72;
  const legX = 8, legY = H - legH - 8;

  ctx.fillStyle = 'rgba(11,17,23,0.7)';
  ctx.fillRect(legX, legY, legW, legH);
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 0.5;
  ctx.strokeRect(legX, legY, legW, legH);

  ctx.font = `500 ${legFontSize}px JetBrains Mono`;
  ctx.textAlign = 'left';
  for (let i = 0; i < legItems.length; i++) {
    const [key, { color, label }] = legItems[i];
    const ly = legY + legPad + (i + 0.65) * legLineH;
    ctx.beginPath(); ctx.arc(legX + legPad + legDot, ly, legDot, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},0.85)`; ctx.fill();
    ctx.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},0.6)`;
    ctx.fillText(label, legX + legPad + legDot * 2 + legGap, ly + legFontSize * 0.35);
  }
}

// ─── Animation Loop ─────────────────────────────────
let frame = 0;
function animate() {
  const t = frame * 0.016;
  if (!dragging && Date.now() - lastDragTime > 5000) rotation += 0.03 / zoomLevel;
  drawGlobe(t);
  frame++;
  requestAnimationFrame(animate);
}

// ─── Init ───────────────────────────────────────────
loadLandData();
fetchFlights(); fetchShips(); connectSSE(); animate();
</script>
</body>
</html>
